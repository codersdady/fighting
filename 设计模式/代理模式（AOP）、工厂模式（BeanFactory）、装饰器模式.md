# 代理模式（AOP）、工厂模式（BeanFactory）、装饰器模式

## 装饰器模式

[装饰器模式 Decorator 结构型](https://www.cnblogs.com/noteless/p/9603041.html)

- 装饰器模式分为两部分，一部分是使用实体的主题（用户），另一部分是实体和装饰器。

- 实体和装饰器都实现同一个接口，其中装饰器可以设置为抽象类，供其他子装饰器类实现。

- 实体类使用实体的方法参数为装饰器和实体类所实现的接口，所以需要先实现实体类，在通过装饰器一步步修饰这个实体。

  ```java
  customerC.buy(new Bacon(new Sausage(new NotelessHandPancake())));
  ```

- 用户使用装饰器装饰好的类时，会先使用用装饰器入参的类，递归这个操作。

  ```java
  @Override
  public String offerHandPancake() {
      return super.offerHandPancake()+" 加青菜";
  }
  ```

## 代理模式

[装饰器模式和代理模式的区别](https://www.cnblogs.com/yanggb/p/10952843.html)

[java动态代理实现与原理详细分析](https://www.cnblogs.com/gonjan-blog/p/6685611.html)

装饰器模式与代理模式较为相似，代理类和装饰器类都和目标实体类实现了同一个接口。

- 实体类的new由用户控制，然后把这个对象交给代理类。
- 在使用代理类时，直接调用代理类与实体类相同的方法即可，一般在这个方法中，会调用目标实体类的方法（就等于把调用过程交给了代理类，好像中介一样，他去做租房的操作，在租房前后做一些增强功能），在调用目标实体类的方法前后可以进行一些增强操作。
- 动态代理不需要和实体类实现同一个接口，可以通过JDK的动态代理机制和cglib的动态代理机制实现。
  - JDK动态代理机制需要实现InvocationHandler接口，重写invoke方法，并通过Proxy类的newProxyInstance动态构建代理类。
  - cglib代理类Proxy继承RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。 

**代理更多的是强调对对象的访问控制，比如说，访问A对象的查询功能时，访问B对象的更新功能时，访问C对象的删除功能时，都需要判断对象是否登陆，那么我需要将判断用户是否登陆的功能抽提出来，并对A对象、B对象和C对象进行代理，使访问它们时都需要去判断用户是否登陆，简单地说就是将某个控制访问权限应用到多个对象上；**

**而装饰器更多的强调给对象加强功能，比如说要给只会唱歌的A对象添加跳舞功能，添加说唱功能等，简单地说就是将多个功能附加在一个对象上。**

## 工厂模式

[工厂模式和代理模式](https://www.cnblogs.com/daidao/p/8493888.html)

工厂模式是把实体对象的实现过程交给了工厂类完成。

- 实体类不需要用户new。
- 用户new工厂对象，调用工厂对象的创建实体对象的方法即可，返回的是对象。