# 操作系统

## 物理内存和虚拟内存

### 物理内存

- 内存条，在32位平台下，寻址范围是$2^232$也就是4G，实际并不能全部使用4G。

### 虚拟内存

- 进程认为得到了连续的4G内存空间,实际被分割成多个物理内存碎片，还有一部分在外部磁盘存储器上，在需要时进行数据交换。
- 虚拟内存访问地址的流程：
  - 每次访问地址空间上的某一个地址，许哟啊把地址翻译位实际物理内存地址。
  - 所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上。
  - 进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（如磁盘），在物理内存上的哪里。（页表记录）。
  - 页表的每一个表项分两部分，一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。
  - 当进程访问某个虚拟地址的时候，就会先看页表，如果对应数据不在物理内存上，就会发生缺页异常。
  - 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

![1](/pic/1.png)

- 页表的工作原理

  ![](/pic/2.png)

- 当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

  另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

  可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

- 优点

  - 既然每个进程的内存空间都是一致而且固定的（32位平台下都是4G），所以链接器在链接可执行文件时，可以设定内存地址，而不用去管这些数据最终实际内存地址，这交给内核来完成映射关系
  - 当不同的进程使用同一段代码时，比如库文件的代码，在物理内存中可以只存储一份这样的代码，不同进程只要将自己的虚拟内存映射过去就好了，这样可以节省物理内存
  - 在程序需要分配连续空间的时候，只需要在虚拟内存分配连续空间，而不需要物理内存时连续的，实际上，往往物理内存都是断断续续的内存碎片。这样就可以有效地利用我们的物理内存