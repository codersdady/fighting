# JVM

[调优总结](https://www.cnblogs.com/andy-zhou/p/5327288.html)

## JDK是什么

- JDK 是用于支持 Java 程序开发的最小环境。

- 是功能齐全的JavaSDK，拥有JRE所拥有的一切，还有编译器（javac）和工具。能够创建和编译程序。

## JRE是什么

- JRE是Java运行时环境。
- 运行已编译Java程序所需要的所有内容的集合。
- 包括JVM，Java类库，Java命令和其他的一些基础构建。
- 不能创建新程序。

## JVM

- JVM是运行Java字节码的虚拟机。
- JVM有针对不同系统的实现，使得使用相同字节码，都会给出相同的结果。

## 字节码

- JVM可以理解的代码叫字节码（.class文件），只面向虚拟机。

## 编译型语言

- 执行之前，需要编译过程，把源码编译成机器语言的文件。

- 以后运行不需要编译，执行效率高。

  ![1](pic/1.webp)

## 解释型语言

- 使用专门解释器对源程序逐行解释成特定平台的机器码并立即执行。

- 在执行时才被解释器一行行动态翻译和执行。

- 不需要事先编译，需要解释器。

- 每次将源代码解释成机器码并执行，效率低。

- Java需要编译，但编译后不能直接运行。

  ![](pic/2.webp)

## 永久代和元空间

- 字符串存在永久代中，容易出现性能问题和内存溢出。
- 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

## 常量池

- 在 jdk1.6（含）之前**运行时常量池逻辑包含字符串常量池**存放在方法区, 此时**hotspot**虚拟机对方法区的实现为**永久代**
- 常量池在 jdk1.7（含）之后字符串常量池被从**方法区拿到了堆**中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,**运行时常量池剩下的东西还在方法区**, 也就是hotspot中的永久代 
- jdk1.8 移除了**永久代**用**元空间(Metaspace)**取而代之, 这时候**字符串常量池还在堆**, **运行时常量池还在方法区**, 只不过方法区的实现从永久代变成了元空间(Metaspace) 

## JVM调优总结

### 数据类型

- 基本类型：byte,short,int,long,char,float,double,Boolean,returnAddress
- 引用类型：类类型，接口类型和引用类型（数组）。

### 栈与堆

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

- 栈：
  - java中一个线程对应一个线程栈，栈是运行单位，里边存储的信息都与当前线程对应，包括局部变量表、程序运行状态、方法返回值等。
  - Main函数是栈的起始点，也是程序的起始点。
  - 栈中存的是**基本数据类型和堆中对象引用**。因为基本类型不会出现动态增长的情况，长度固定。

- 堆：
  - 所有线程共享，只存储对象信息。

### 总结

- 年轻代大小选择：
  - 响应时间优先的应用：尽可能大，直到接近系统的最低响应时间限制。年轻代收集发生的频率是最小的。减少到达年老代的对象。
  - 吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。堆响应时间没要求，垃圾收集可以并行进行。
- 年老代大小选择：
  - 响应时间优先的应用：年老代使用并发收集器，如果堆设置小了，可以灰照成内存碎片、高回收频率以及应用暂停而使用传统的标记清楚方式；如果对设置大了，需要较长的手机时间。需要考虑：
    - 并发垃圾收集信息
    - 持久代并发收集次数
    - 传统GC信息
    - 花在年轻代和年老代回收上的时间比例减少年轻代和年老代花费的时间，一般会提高应用的效率。
- 吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的老年代。这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代存放长期存活对象。
- 较小堆引起的碎片问题：因为老年代的并发收集器使用标记、清楚算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配较大的对象。当堆空间较小时，会出现碎片，如果并发收集器找不到足够空间，会停止并使用传统的标记、清除方式回收。如果出现碎片，可能需要如下配置：
  - -XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。
  - -XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩

## Java参数传递（值传递）

- Java没有指针，所以都是进行传值调用。
- 程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。
- 在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。

## 如何区分垃圾

获取哪线对象正在被使用，需要从Java栈开始。一个栈是与一个线程对应，如果又多个线程，需要对这些对应的所有的栈进行检查。

![root](pic/root.png)

还有系统运行时的寄存器，也是存储程序运行数据的。所以以栈或寄存器中的引用为起点，可以找到栈中的对象，这种引用逐步扩展，形成了一颗以Java栈中引用所对应的对象为根节点的一颗对象树，如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。

- 垃圾回收的起点是一线根对象（java栈，静态变量，寄存器）。这种回收方式，是“标记-清除”。

## 什么情况下触发垃圾回收

### Scavenge GC

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

### Full GC

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：

> - 年老代（Tenured）被写满 ·
> - 持久代（Perm）被写满  · System.gc()被显示调用  
> - 上一次GC之后Heap的各域分配策略动态变化

## 堆大小设置

JVM堆大小限制：1. 操作系统（32bit、64bit）2.系统可用虚拟内存限制 3.系统可用物理内存限制。

```java
java -Xmx3550m -Xms3550m -Xmn2g –Xss128k

-Xmx3550m：设置JVM最大可用内存为3550M。

-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。

-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
```

其他设置参数：

```java
-Xms:初始堆大小
-Xmx:最大堆大小
-Xmn:设置新生代大小（对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置）
    
-XX:NewSize=n:设置年轻代大小
-XX:MaxnewSize：表示新生代可被分配的内存的最大上限；当然这个值应该小于-Xmx的值；

-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4
-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
    
-XX:PermSize：表示非堆区初始内存分配大小（方法区）
-XX:MaxPermSize：表示对非堆区分配的内存的最大上限（方法区）。
-XX:MaxPermSize=n:设置持久代大小
```

## 垃圾回收器的瓶颈

传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是Full GC所带来的应用暂停。在一些对实时性要求很高的应用场景下，GC暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，**如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内**，但是这样有限制了应用本身的处理能力，同样也是不可接收的。

分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。

## G1垃圾回收器

> 支持很大的堆
>
> 高吞吐量  
>
> ​	--支持多CPU和垃圾回收线程  
>
> ​	--在主线程暂停的情况下，使用并行收集 
>
> ​	 --在主线程运行的情况下，使用并发收集
>
> 实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收

